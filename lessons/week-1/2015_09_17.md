# Objectives
* Articulate the use cases of a block
* Understand how blocks relate to scope

# What is a block?

An Objective-C `class` defines an *object that combines data with related behavior*. Sometimes, it makes sense just to represent a *single task* or *unit of behavior*, rather than a collection of methods.

**Blocks** are a language-level feature added to C, Objective-C and C++, which **allow you to create distinct segments of code that can be passed around to methods or functions as if they were values**. Blocks are Objective-C objects, which means they can be added to collections like NSArray or NSDictionary. They also have the ability to capture values from the enclosing **scope**, making them similar to closures or lambdas in other programming languages.

### Block Syntax
The syntax to define a block literal uses the caret symbol `(^)`, like this:
```objective-c
^{
  NSLog(@"This is a block");
}
```

As with function and method definitions, the braces indicate the start and end of the block. In this example, the block doesn’t return any value, and doesn’t take any arguments.

In the same way that you can use a function pointer to refer to a C function, you can declare a variable to keep track of a block, like this:

```objective-c
void (^simpleBlock)(void);
```

If you’re not used to dealing with C function pointers, the syntax may seem a little unusual. This example declares a variable called simpleBlock to refer to a block that takes no arguments and doesn’t return a value, which means the variable can be assigned the block literal shown above, like this:

```objective-c
simpleBlock = ^{
  NSLog(@"This is a block");
};
```

This is just like any other variable assignment, so the statement must be terminated by a semi-colon after the closing brace. You can also combine the variable declaration and assignment:

```objective-c
void (^simpleBlock)(void) = ^{
  NSLog(@"This is a block");
};
```

Once you’ve declared and assigned a block variable, you can use it to invoke the block:
```objective-c
simpleBlock();
```

**code break**

### Blocks Take Arguments and Return Values

As an example, consider a variable to refer to a block that returns the result of multiplying two values:

```objective-c
double (^multiplyTwoValues)(double, double);
```

The corresponding block literal might look like this:
```objective-c
^ (double firstValue, double secondValue) {
    return firstValue * secondValue;
}
```

The firstValue and secondValue are used to refer to the values supplied when the block is invoked, just like any function definition. In this example, the return type is inferred from the return statement inside the block.

If you prefer, you can make the return type explicit by specifying it between the caret and the argument list:

```objective-c
^ double (double firstValue, double secondValue) {
    return firstValue * secondValue;
}
```

Once you’ve declared and defined the block, you can invoke it just like you would a function:

```objective-c
double (^multiplyTwoValues)(double, double) =
  ^(double firstValue, double secondValue) {
    return firstValue * secondValue;
  };
 
double result = multiplyTwoValues(2,4);
 
NSLog(@"The result is %f", result);
```

**code break**

### Blocks Can Capture Values from the Enclosing Scope

If you declare a block literal from within a method, for example, it’s possible to capture any of the values accessible within the scope of that method, like this:

```objective-c
- (void)testMethod {
  int anInteger = 42;
 
  void (^testBlock)(void) = ^{
    NSLog(@"Integer is: %i", anInteger);
  };
 
  testBlock();
}
```

In this example, anInteger is declared outside of the block, but the value is captured when the block is defined.

Only the value is captured, unless you specify otherwise. This means that if you change the external value of the variable between the time you define the block and the time it’s invoked, like this:

```objective-c
int anInteger = 42;
 
void (^testBlock)(void) = ^{
  NSLog(@"Integer is: %i", anInteger);
};
 
anInteger = 84;
 
testBlock();
```
